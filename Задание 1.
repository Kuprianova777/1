import pygame
from random import choice

RES = ШИРИНА, ВЫСОТА = 1202, 902
ПЯТНА = 50
кол-во столбцов, строк = ШИРИНА // ПЯТНА, ВЫСОТА // ПЯТНА

pygame.init()
sc = pygame.display.set_mode(RES)
clock = pygame.time.Часы()


класс Ячейка:
 def __init__(self, x, y):
 self.x, self.y = x, y
 self.walls = {'top': True, 'right': True, 'bottom': True, 'left': True}
 self.visited = False

 def draw_current_cell(self):
 x, y = self.x * TILE, self.y * TILE
 pygame.draw.rect(sc, pygame.Цвет («шоколадно-коричневый»), (x + 2, y + 2, TILE - 2, TILE - 2))

 def draw(self):
 x, y = self.x * TILE, self.y * TILE
 если self.посещено:
 pygame.draw.rect(sc, pygame.Цвет («черный»), (x, y, TILE, TILE))

 если self.walls['верх']:
 pygame.draw.line(sc, pygame.Color('темно-оранжевый'), (x, y), (x + TILE, y), 3)
 если self.walls['справа']:
 pygame.draw.line(sc, pygame.Color('темно-оранжевый'), (x + TILE, y), (x + TILE, y + TILE), 3)
 если self.walls['внизу']:
 pygame.draw.line(sc, pygame.Color('темно-оранжевый'), (x + TILE, y + TILE), (x, y + TILE), 3)
 если self.walls['слева']:
 pygame.draw.line (sc, pygame.Цвет ('darkorange'), (x, y + ПЛИТКА), (x, y), 3)

 проверка определения ячейки (self, x, y): 
 find_index = лямбда x, y: x + y * столбцы 
 если x < 0 или x > cols - 1 или y < 0 или y > строки - 1:
 верните значение False
 верните значение grid_cells[find_index(x, y)]

 def check_neighbors(self):
 neighbors = []
 верните значение top = self.check_cell(self.x, self.y - 1)
 верните значение right = self.check_cell(self.x + 1, self.y)
 верните значение bottom = self.check_cell(self.x, self.y + 1)
 слева = self.check_cell(self.x - 1, self.y)
 если сверху и не посещено сверху:
 соседи.append(сверху)
 если справа и не посещено справа:
 соседи.append(справа)
 если снизу и не посещено снизу:
 соседи.append(снизу)
 если слева и не посещено слева:
 соседи.append(слева)
 вернуть выборку(соседей), если есть соседи, иначе False


определение remove_walls(текущий, следующий):
 dx = текущий.x - следующий.x 
 если dx == 1:
 текущий.walls['слева'] = False 
 следующий.walls['справа'] = False 
 elif dx == -1:
 текущий.walls['right'] = False 
 следующий.walls['left'] = False 
 dy = текущий.y - следующий.y
 если dy == 1:
 current.walls['top'] = False
 next.walls['bottom'] = False
 если dy == -1:
 current.walls['bottom'] = False
 next.walls['top'] = False


grid_cells = [Cell(столбец, строка) для каждой строки в диапазоне (строк) для каждого столбца в диапазоне (столбцов)]
current_cell = grid_cells[0]
stack = []
colors, color = [], 40

while True:
 sc.fill(pygame.Color('темно-серый'))

 для каждого события в pygame.event.get():
 если событие.type == pygame.QUIT:
 выйти()

 [cell.draw() для каждой ячейки в grid_cells]
 current_cell.посещена = True
 current_cell.draw_current_cell()
 [pygame.draw.rect(sc, цвета[i], (cell.x * TILE + 5, cell.y * TILE + 5,
 TILE - 10, TILE - 10), border_radius=12) для i, cell в enumerate(стек)]

 следующая_ячейка = current_cell.check_neighbors()
 если следующая_ячейка:
 next_cell.visited = True
 стек.append(текущая_ячейка)
 цвета.append((min(цвет, 255), 10, 100))
 цвет += 1
 удалить_стены(текущая_ячейка, следующая_ячейка)
 текущая_ячейка = следующая_ячейка
 иначе, если стек:
 текущая_ячейка = стек.pop()

 pygame.display.flip()
 часы.тик(30)
